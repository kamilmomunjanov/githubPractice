План курса
-	Разница между git и github
-	Создание нового репозитория Git
-	Подготовка и сохранение изменений
-	Перемещение между версиями
-	Создание ветвей и слияние ветвейb 
-	Github и создание удаленныйх репозиториев
-	Связывание локальных и удалённых репозиториев
-	Объекты git и их содержимое

 
Git – это распределённая система управления версиями, то есть её основная задача помогать создавать нам различные версии приложения.
Почему стоит использовать git:
-	Позволяет создавать различные версии проектов
-	Быстрый переход между различными версиями проектов
-	Откат к предыдущим версиям при необходимости
-	Улучшает процесс командной работы над одними и теми же проектами
-	Независимая одновременная разработка различных новых функций в проекте


GitHub - это веб-платформа для хостинга и совместной работы над проектами, использующими систему управления версиями Git. Она предоставляет возможность разработчикам загружать (push) свои репозитории (проекты) на серверы GitHub, делиться кодом с другими участниками и управлять проектом с использованием различных инструментов и функций.

Git – это распределённая система контроля версий.
Github – сервис хостинга git репозиториев.

Git –version – отображает версию git.

Git config –global user.name “..your name..” - изменение конфигураций git
Git config –global user.email ..your email.. - изменение конфигураций git

Git config –list – проверка настроек git, то есть имя, почту и остальные.

Команды Shell
-	Переход в папку - сd ~/Desktop
-	Создание новой папки – mkdir my-project
-	Переход в папку – cd my-project
-	Создание файла с текстом – echo “some text” > file.txt
-	Список файлов в папке – ls
-	Список файлов в другой папке папке – ls my-project
-	Чтение файла – cat file.txt
-	Удаление файла – rm file.txt
-	Полный путь папки где я нахожусь – pwd

Создание нового репозитория
Git init – создание нового git репозитория

После инициализации создаётся скрытая папка .git

Отображение скрытых папок и файлов:
Git bash(windows), mac – ls -la
Powershell(windows) -  ls -Force


Области git:

Рабочая директория  --- Индекс --- Репозиторий
Working directory  --- Staging area --- Repository

Working directory  - показывает все видимые файлы и также папки, это и есть рабочая директория. Содержимое проекта.
Staging area – в эту область добавляются файлы, до того как мы хотим их сохранить, подготавливаем файлы до сохранения. То есть файлы или папки которые уже готовы к коммиту(которые были изменены предварительно либо созданы новая папка или файл). Git status – отобразит все файлы или папки которые готовы к коммиту и сохранению в репозитории.
Repository – после того как мы уже подготовили файлы, мы можем сохранить изменения и записать их в репозиторий. Это именно то что находится в скрытой папке .git, внутри .git есть папка objects и именно в этой папке сохраняются все версии тех или иных файлов нашего проекта. Кроме того в репозитории сохраняются другие объекты, такие как коммиты(указатели на определённые версии нашего проекта).

Для каждого git объекта(.git --- objects --- sjf759938fugx.file) создаётся уникальный хэш. Как он генерируется мы рассмотрим ниже. Это уникальный идентификатор определеннёго объект git. Все объекты git находятся в папке .git --- objects.

В репозитории хранятся разные версии файлов.

Working directory – видимая область git.

Staging area and repository – скрытые области git.

 

Первая и вторая версии это уже разные версии файла app.js. И в мире git это абсолютно два разных объекта. И эти объекты записаны под разными именами в репозитории git и они находятся непосредственно в папке objects.

 

 
Git add . – добавление всех новых изменений в индекс.
Git checkout – перемещение между версиями. Например, я перехожу на самую первую, старую версию. В таком случае git берёт объекты из репозитория и перемещает их в рабочую директорию. И это приводит к тому что содержимое рабочей директории полностью перезаписывается, некоторые файлы могут исчезнуть, а некоторые появится. После того как введём команду git checkout.
  

Untracked – файлы которые мы только добавили в рабочую директорию.
Staged – файлы которые мы добавили в индекс.
Unmodified – после того как мы сохранили файл в репозитории. То есть когда в рабочей директории и в репозитории находится одна и та же версия файла.
Modified – файлы которые мы изменили. Следом они идут в staged, затем снова становятся unmodified и так по кругу.


Объекты git. 
 
Каждый объект в git имеет уникальный id(sha1 хэш).
 


Что такое коммит?
Коммит – указатель на дерево. Дерево это то как git представляет каждую папку(папка в папке, вложенность).
 

В этом случае гит создаст пять объектов. Каждый будет иметь уникальный sha1 ключ. Самая верхняя корневая папка и есть скрытая папка .git. 
 Коммит указывает на корневое дерево. .git в разных версиях будет разный.
При создании коммита гит сначало создаёт вот эти все объекты, а именно пять объектов два типа tree, три типа blob и плюс один объект коммит. И этот коммит ссылается на опредеённое корневое дерево.

 
Как и у любого коммита есть свой sha1 хэш. В коммите находится sha1 хэш определённого дерева на которое ссылается определённый коммит. Все объекты гит связываются между собой с помощью хэшей. Родительский коммит – каждый следующий коммит сыллается на предыдущий коммит это их и связывает. Их может быть несколько. Самый первый коммит – это корневой коммит(root coomit).
Head – указатель коммита. В рабочей директории проекта мы видим ту версию проекта на который ссылается указатель head.
 
Но мы можем перемещать этот указатель head между коммитами.
Обычно head является указателем на определённую ветку. Ну а ветка является уже ссылкой на коммит. А коммит это ссылка на дерево.
 
При инициализации нового проекта гит создаётся новая ветка. Эта ветка называется master. Если мы создаём проект на github, то ветка по умолчанию будет main. При создании нового коммита ветка автоматически ссылается на последний коммит.



Основные команды гит:
-	Git status – отображает текущее состояние гит репозитория. Те файлы которые находятся в индексе.
-	 Git add <files> - подготовка файлов перед  коммитом. Добавляет файлы в stagion area(индекс).
-	Git add . – добавляет все изменённые файлы.
-	Git commit -m “message” – создание коммита с записью изменений в репозиторий. Добавляет файлы в област репозитория.
-	Git log – просмотр истории изменений(коммитов). Показывает все коммиты которые были сделаны до последнего коммита.
-	Git checkout <commit hash> - переход в определённую версию коммита по sha1 хэшу коммита.
-	Git checkout <branch name> - переход в определённую версию проекта по названию ветки.
-	Git rm –cached <file> - удаляет файл из индекса
-	Git rm -r –cached . – удаляет все файлы из индекса
-	Git rm -r –cached .,     git commit -m “Remove all files from index and working directory” – эти две команды сначала убирают файлы из индекса, а затем фиксируют изменения в репозитории, что означает удаление файлов из директории.
-	Git cat-file -t <sha1 hash> - можно читать содержимое гит по определённому хэшу объекта.
-	git cat-file -p  0f4af25 – можно прочитать содержимое коммита.
-	cd .git/objects – переход сразу на две папки.
-	cd ../.. – выход сразу на две папки назад.


Ветки в гит.

Ветка – это ссылка на определённый коммит.
И когда мы работаем в рамках одной ветки эта ссылка автоматически перемещается на последний коммит.
В примере ниже у нас кроме ветки main появились ещё две ветки. И есть ряд коммитов которые были сделаны в разных ветках. Как же переключаться между разными ветками? Верно, путём перемещения указателся head на другую ветку Git checkout feature1. И если мы создадим коммит на другой ветке, то коммит создастся в этой текущей ветке.
Git branch <branch name> - создание новой ветки
Git checkout <branch name> - переход в новую ветку
Git checkout -b < branch name > - создание новой ветки и переход в неё
Git branch – отображает список всех всеток которые присутствую в локальном репозитории
Git branch -m <new branch name> - переименование текущей ветки
Git branch -d < branch name > - удаление ветки(текущую ветку удалить нельзя)
 


Слияние веток.

 
Ветки могут развиваться параллельно. И у нового коммита будут ссылки на два родительских комита. Это так называемый merge commit. После слияния веток ветку new-feature можно удалить. В этой ветке нет необходимости, ведь все изменения из этой ветки мы перенесли в основную. Иногда при попытке слияния веток возникают конфликты. Это возникает когда один и тот же файл, например, был изменён в разных ветках.

Git merge <feature branch name> - слияние другой ветки(feature branch) в текущую ветку(receiving branch)
 

Процесс слияния веток.
-	Создать новую ветку new-feature из ветки main.(git branch new-feature).
-	Перейти в новую ветку new-feature.( git checkout new-feature).
-	Внести изменения в проект(создать новые файлы и папки, изменить существующие)
-	Создать коммит или несколько коммитов в ветке new-feature.
-	Перейти обратно в ветку main и также создать коммиты. Потому что две ветки и тд могут развиваться параллельно. При этом в ветку main во время разработки ветки new-feature мы можем выполнять слияние и других веток.
-	Когда мы закончили работу в new-feature мы должны выполнить слияние ветки new-feature в ветку main. Для этого переходим в ветку main с помощью git checkout main, затем git merge new-feature. Тем самым мы производим слияние ветки new-feature в ветку main.
-	После слияния ветку new-feature можно удалить. Потому что ветка это указатель на определённый коммит. После слияния этот указатель нам и не нужен. Потому что вся история коммитов из ветки new-feature сохранена в ветке main.

Git merge -m “Commit text” <feature branch name> - слияние другой ветки(feature branch) в текущую ветку(receiving branch)

 



Сервисы хостинга гит репозиториев.
Это простыми словами – удалённый репозиторий на хостинге.
 


Pull Request (PR) в контексте GitHub представляет собой механизм для предложения изменений (кода, документации, и т.д.) в репозиторий. Этот механизм часто используется в процессе совместной разработки программного обеспечения с использованием системы контроля версий Git.
 

Git clone <url> - клонирование удалённого репозитория в локальный.
Origin – имя удалённого репозитория по умолчанию.
После команды git clone, то гит не только скачивает удалённый репозиторий на компьютер, но и создаёт связь между удалённым репозиторием и локальным репозиторием и локально у вас появится удалённый сервер под названием origin. И мы всегда можем продолжать взаимодействие с этим удалённым сервером с помощью введения команд git push и git pull. Например, если я клонировал репозиторий у какого то автора этого кода, то после клонирования я имею доступ ко всей истории коммитов, в целом имею доступ к коду, и если автор добавит в дальнейшем новый коммит, то я с помощью команды git pull могу этот коммит добавить себе локально. 
Кроме того в каждом репозитории могут существовать много разных веток и ветки могут присутсвовать и в вудалённом репозитории, так вот после того как мы клонируем удалённый репозиторий локально, то после введения команды git branch мы не увидим ветки которые созданы в удалённом репозитории. Для этого:
Git branch -a  - отображает все ветки, включая те, которые находятся в удалённых репозиториях.
И после этого с помощью команды git checkout <branch name> перейти в любую ветку.
Git pull – загрузка и применение изменений с удалённой ветки в локальную.
Если я нахожусь, например в ветке new-feature, то после команды git pull я скачаю все изменения которые произошли именно в ветке new-feature.

Git push – загрузка изменений из локальной ветки в ветку удалённого репозитория.
Взаимодействия между локальным и удалённым репозиториями происходят в рамках конкретной ветки.


Связь существующего локального репозитория с удаленным.

Это как раз та ситуация когда мы создали локальный репозиторий и работали с ним локально без пуша его в удалённый.

Git remote add origin <url> - подключение удалённого репозитория.
Origin – имя удалённого репозитория. Более того мы можем связывать свой локальный репозиторий с несколькими удалёнными репозиториями.
Git push -u origin <branch> - загрузка изменений из локальной ветки в удалённую с созданием связи между ними. А веткку в раздела branch нужно указывать ветку удалённого репозитория.
Git push – дальнейшие загрузки изменениё в  ветку удалённого репозитория после установки связи между локальной и удалённой ветками.
Git pull – скачиваем обновления.

Git remote -v  - показывает ссылку на удалённый репозиторий и название удалённого репозитория.
Git remote - показывает имя удалённого репозитория.
Git branch -vv – показывает связь между локальным репозиторием и удалённым через связь веток.



.gitignore - это файл, который используется в системе управления версиями Git для указания файлов и каталогов, которые не следует учитывать при отслеживании изменений в репозитории. Этот файл содержит шаблоны, которые определяют, какие файлы или каталоги должны быть проигнорированы Git при выполнении операций, таких как git status или git add.
Зачем нужен файл .gitignore?
1.	Исключение временных и автоматически создаваемых файлов:
•	В процессе разработки могут создаваться временные или автоматически сгенерированные файлы, которые не имеют значения для версионного контроля. Например, файлы логов, временные файлы компиляции и т.д. .gitignore позволяет игнорировать их, что делает вывод команды git status более чистым.
2.	Исключение файлов конфигурации и личных данных:
•	Часто в проекте содержатся файлы конфигурации, содержащие личные данные (например, ключи API), которые не должны попадать в репозиторий. Файл .gitignore позволяет исключить такие файлы из версионного контроля.
3.	Управление зависимостями и бинарными файлами:
•	Если вы используете систему управления зависимостями (например, npm, Composer), вы можете исключить каталоги с установленными зависимостями, чтобы не добавлять их в репозиторий. Также, бинарные файлы, такие как исполняемые файлы, могут быть исключены из-за их объема.



Надо изучить:

-	Внутреннее устройство git.
-	Различные методы слияния ветвей(3-way, fast forward), разрешение конфликтов.
-	Работа с Pull Requests(PRs) на Github.
-	Совместная работа с публичными Github репозиториями.
-	Git rebasing.
-	Тэги Git.
-	Игнорирование файлов с помощью .gitignore.
-	Git reset, Git Revert, Git hooks, Git stash.
